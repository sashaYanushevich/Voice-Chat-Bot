<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Interview - Voice Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .main-container {
            width: 100%;
            max-width: 800px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .header {
            padding: 2rem;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        .candidate-info {
            font-size: 0.9rem;
            color: #b3b3b3;
            margin-bottom: 1rem;
        }

        .status-indicator {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            display: inline-block;
            margin-top: 0.5rem;
        }

        .status-connected {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .status-listening {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .status-processing {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .chat-area {
            flex: 1;
            padding: 1rem 2rem;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.1);
        }

        .message {
            margin: 1rem 0;
            padding: 1rem 1.5rem;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .user-message {
            background: #0084ff;
            color: white;
            margin-left: auto;
            text-align: right;
        }

        .bot-message {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            padding: 2rem;
            display: flex;
            justify-content: center;
            gap: 2rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .mute-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .mute-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .mute-btn.muted {
            background: #ef4444;
            color: white;
        }

        .mute-btn.listening {
            background: #22c55e;
            color: white;
            animation: pulse 2s infinite;
        }

        .end-call-btn {
            background: #ef4444;
            color: white;
        }

        .end-call-btn:hover {
            background: #dc2626;
            transform: scale(1.05);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }

        .status-text {
            text-align: center;
            padding: 1rem;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>ðŸŽ¯ Google Interview</h1>
            <div id="candidateInfo" class="candidate-info">
                Loading candidate information...
            </div>
            <div id="statusIndicator" class="status-indicator status-connected">
                ðŸ”´ Connecting...
            </div>
        </div>

        <div id="chatArea" class="chat-area">
            <!-- Messages will appear here -->
        </div>

        <div id="statusText" class="status-text">
            Waiting for HR specialist to connect...
        </div>

        <div class="controls">
            <button id="muteBtn" class="control-btn mute-btn" title="Microphone">
                ðŸŽ¤
            </button>
            <button id="endCallBtn" class="control-btn end-call-btn" title="End Interview">
                ðŸ“ž
            </button>
        </div>
    </div>

    <script>
        class VoiceInterview {
            constructor() {
                this.ws = null;
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.isListening = false;
                this.isMuted = true;
                this.userId = this.generateUserId();
                this.candidateData = null;
                this.cvData = null;
                
                // VAD settings
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.vadThreshold = 10;
                this.silenceTimeout = 1500;
                this.silenceTimer = null;
                this.voiceDetected = false;
                this.autoStopTimeout = null;
                
                // Audio playback
                this.audioQueue = [];
                this.isPlayingAudio = false;
                this.currentAudio = null;
                
                this.initElements();
                this.loadCandidateData();
                this.initWebSocket();
            }

            generateUserId() {
                return 'user_' + Math.random().toString(36).substr(2, 9);
            }

            initElements() {
                this.statusIndicatorEl = document.getElementById('statusIndicator');
                this.chatAreaEl = document.getElementById('chatArea');
                this.statusTextEl = document.getElementById('statusText');
                this.muteBtnEl = document.getElementById('muteBtn');
                this.endCallBtnEl = document.getElementById('endCallBtn');
                this.candidateInfoEl = document.getElementById('candidateInfo');

                this.muteBtnEl.addEventListener('click', () => this.toggleMute());
                this.endCallBtnEl.addEventListener('click', () => this.endCall());
            }

            loadCandidateData() {
                try {
                    this.candidateData = JSON.parse(localStorage.getItem('candidateData'));
                    this.sessionId = localStorage.getItem('sessionId');
                    
                    if (this.candidateData) {
                        this.candidateInfoEl.textContent = 
                            `${this.candidateData.firstName} ${this.candidateData.lastName} | ${this.candidateData.email}`;
                    }
                    
                    if (!this.candidateData || !this.sessionId) {
                        this.candidateInfoEl.textContent = 'Error: Missing candidate data';
                        this.statusTextEl.textContent = 'Please go back and complete the setup form';
                        return false;
                    }
                    
                    return true;
                } catch (error) {
                    this.candidateInfoEl.textContent = 'Error loading candidate data';
                    this.statusTextEl.textContent = 'Please go back and complete the setup form';
                    return false;
                }
            }

            async initWebSocket() {
                if (!this.loadCandidateData()) return;

                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws/${this.userId}?session_id=${this.sessionId}`;
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.updateStatus('connected', 'ðŸŸ¢ Connected');
                        this.updateStatusText('CV already uploaded. Starting interview...');
                    };

                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleMessage(data);
                    };

                    this.ws.onclose = () => {
                        this.updateStatus('disconnected', 'ðŸ”´ Disconnected');
                        this.updateStatusText('Connection lost. Please refresh the page');
                    };

                    this.ws.onerror = () => {
                        this.updateStatus('error', 'âŒ Error');
                        this.updateStatusText('Connection error');
                    };

                } catch (error) {
                    this.updateStatus('error', 'âŒ Error');
                    this.updateStatusText('Failed to connect to server');
                }
            }



            updateStatus(type, text) {
                const classes = {
                    'connected': 'status-connected',
                    'listening': 'status-listening', 
                    'processing': 'status-processing',
                    'disconnected': 'status-connected',
                    'error': 'status-connected'
                };
                
                this.statusIndicatorEl.className = `status-indicator ${classes[type] || 'status-connected'}`;
                this.statusIndicatorEl.textContent = text;
            }

            updateStatusText(text) {
                this.statusTextEl.textContent = text;
            }

            addMessage(text, isUser = false) {
                const messageEl = document.createElement('div');
                messageEl.className = `message ${isUser ? 'user-message' : 'bot-message'}`;
                messageEl.textContent = text;
                
                this.chatAreaEl.appendChild(messageEl);
                this.chatAreaEl.scrollTop = this.chatAreaEl.scrollHeight;
            }

            async toggleMute() {
                if (this.isMuted) {
                    await this.startListening();
                } else {
                    this.stopListening();
                }
            }

            async startListening() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });

                    this.isListening = true;
                    this.isMuted = false;
                    
                    this.muteBtnEl.classList.add('listening');
                    this.muteBtnEl.classList.remove('muted');
                    this.updateStatus('listening', 'ðŸŽ§ Listening');
                    this.updateStatusText('Speak! I\'m listening');

                    // Web Audio API for VAD
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    
                    this.analyser.fftSize = 512;
                    this.analyser.smoothingTimeConstant = 0.3;
                    this.microphone.connect(this.analyser);

                    // MediaRecorder
                    this.mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });

                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        if (this.audioChunks.length > 0) {
                            this.processRecording();
                        }
                    };

                    this.startVoiceDetection();

                } catch (error) {
                    this.updateStatusText('Microphone access error. Please allow access and try again');
                }
            }

            stopListening() {
                this.isListening = false;
                this.isMuted = true;
                
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                if (this.mediaRecorder && this.mediaRecorder.stream) {
                    this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                }

                if (this.audioContext) {
                    this.audioContext.close();
                }

                this.muteBtnEl.classList.remove('listening');
                this.muteBtnEl.classList.add('muted');
                this.muteBtnEl.textContent = 'ðŸ”‡';
                this.updateStatus('connected', 'ðŸ”´ Microphone off');
                this.updateStatusText('Microphone off. Click to enable');
            }

            startVoiceDetection() {
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                let consecutiveDetections = 0;
                let consecutiveSilence = 0;
                const requiredDetections = 2;
                const requiredSilence = 20;

                const detectSound = () => {
                    if (!this.isListening) return;

                    this.analyser.getByteFrequencyData(dataArray);
                    
                    let sum = 0;
                    let rms = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        sum += dataArray[i];
                        rms += dataArray[i] * dataArray[i];
                    }
                    const average = sum / bufferLength;
                    const rmsValue = Math.sqrt(rms / bufferLength);
                    const soundLevel = Math.max(average, rmsValue * 0.5);

                    if (soundLevel > this.vadThreshold) {
                        consecutiveDetections++;
                        consecutiveSilence = 0;
                        
                        if (consecutiveDetections >= requiredDetections && !this.voiceDetected) {
                            this.onVoiceStart();
                        }
                        
                        if (this.silenceTimer) {
                            clearTimeout(this.silenceTimer);
                            this.silenceTimer = null;
                        }
                    } else {
                        consecutiveDetections = 0;
                        consecutiveSilence++;
                        
                        if (this.voiceDetected && consecutiveSilence >= requiredSilence && !this.silenceTimer) {
                            this.silenceTimer = setTimeout(() => {
                                this.onVoiceEnd();
                            }, this.silenceTimeout);
                        }
                    }

                    requestAnimationFrame(detectSound);
                };

                detectSound();
            }

            onVoiceStart() {
                if (this.isRecording) return;

                this.isRecording = true;
                this.voiceDetected = true;
                this.audioChunks = [];
                
                this.updateStatusText('ðŸŽ¤ Recording...');
                this.mediaRecorder.start();
                
                this.autoStopTimeout = setTimeout(() => {
                    if (this.isRecording) {
                        this.onVoiceEnd();
                    }
                }, 10000);
            }

            onVoiceEnd() {
                if (!this.isRecording) return;

                this.voiceDetected = false;
                this.silenceTimer = null;
                
                if (this.autoStopTimeout) {
                    clearTimeout(this.autoStopTimeout);
                    this.autoStopTimeout = null;
                }
                
                this.stopRecording();
            }

            stopRecording() {
                if (!this.isRecording) return;

                this.isRecording = false;
                this.mediaRecorder.stop();
                this.updateStatusText('ðŸ“¤ Processing...');
            }

            async processRecording() {
                if (this.audioChunks.length === 0) return;

                try {
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                    
                    if (audioBlob.size < 100) return;
                    
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const audioData = new Uint8Array(arrayBuffer);
                    const base64Audio = btoa(String.fromCharCode.apply(null, audioData));
                    
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({
                            type: 'audio',
                            audio: base64Audio
                        }));
                    }

                } catch (error) {
                    this.updateStatusText('âŒ Recording processing error');
                }
            }

            handleMessage(data) {
                switch (data.type) {
                    case 'connected':
                        this.updateStatusText(data.message);
                        break;



                    case 'status':
                        this.updateStatus('processing', 'ðŸ¤” Thinking');
                        this.updateStatusText(data.message);
                        break;

                    case 'user_text':
                        this.addMessage(data.text, true);
                        break;

                    case 'bot_text':
                        this.addMessage(data.text, false);
                        this.updateStatus('processing', 'ðŸ”Š Speaking');
                        this.updateStatusText('Playing response...');
                        break;

                    case 'audio_chunk':
                        this.queueAudioChunk(data.audio, data.chunk_index, data.total_chunks);
                        break;

                    case 'completed':
                        // Auto-enable microphone after HR response
                        if (this.isMuted) {
                            this.startListening();
                        } else {
                            this.updateStatus('listening', 'ðŸŽ§ Listening');
                            this.updateStatusText('Ready for your response');
                        }
                        break;

                    case 'error':
                        this.updateStatusText('âŒ ' + data.message);
                        break;
                }
            }

            queueAudioChunk(base64Audio, chunkIndex, totalChunks) {
                this.audioQueue.push({
                    audio: base64Audio,
                    index: chunkIndex,
                    total: totalChunks
                });

                if (!this.isPlayingAudio) {
                    this.playNextChunk();
                }
            }

            async playNextChunk() {
                if (this.audioQueue.length === 0) {
                    this.isPlayingAudio = false;
                    return;
                }

                this.isPlayingAudio = true;
                const chunk = this.audioQueue.shift();

                try {
                    const audioUrl = await this.createAudioUrl(chunk.audio);
                    const audio = new Audio(audioUrl);
                    this.currentAudio = audio;

                    this.updateStatusText(`ðŸ”Š Playing chunk ${chunk.index + 1}/${chunk.total}`);

                    audio.addEventListener('ended', () => {
                        URL.revokeObjectURL(audioUrl);
                        this.currentAudio = null;
                        this.playNextChunk();
                    });

                    audio.addEventListener('error', () => {
                        URL.revokeObjectURL(audioUrl);
                        this.currentAudio = null;
                        this.playNextChunk();
                    });

                    await audio.play();

                } catch (error) {
                    this.playNextChunk();
                }
            }

            async createAudioUrl(base64Audio) {
                return new Promise((resolve, reject) => {
                    try {
                        const binaryString = atob(base64Audio);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }

                        const audioBlob = new Blob([bytes], { type: 'audio/mpeg' });
                        const audioUrl = URL.createObjectURL(audioBlob);
                        resolve(audioUrl);
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            endCall() {
                if (this.isListening) {
                    this.stopListening();
                }
                
                this.stopAudioPlayback();
                
                if (this.ws) {
                    this.ws.close();
                }
                
                this.updateStatus('disconnected', 'ðŸ“ž Interview ended');
                this.updateStatusText('Interview completed. Thank you!');
                
                this.muteBtnEl.disabled = true;
                this.endCallBtnEl.disabled = true;
                
                // Clear localStorage
                localStorage.removeItem('candidateData');
                localStorage.removeItem('sessionId');
                
                // Redirect back to setup after 3 seconds
                setTimeout(() => {
                    window.location.href = '/';
                }, 3000);
            }

            stopAudioPlayback() {
                this.audioQueue = [];
                this.isPlayingAudio = false;
                
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio = null;
                }
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new VoiceInterview();
        });
    </script>
</body>
</html> 