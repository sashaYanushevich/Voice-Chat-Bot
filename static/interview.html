<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Interview - Voice Chat</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1e1e1e 0%, #2d2d2d 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
        }

        .main-container {
            width: 100%;
            max-width: 800px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .header {
            padding: 2rem;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        .candidate-info {
            font-size: 0.9rem;
            color: #b3b3b3;
            margin-bottom: 1rem;
        }

        .status-indicator {
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            display: inline-block;
            margin-top: 0.5rem;
        }

        .status-connected {
            background: rgba(34, 197, 94, 0.2);
            color: #22c55e;
        }

        .status-listening {
            background: rgba(59, 130, 246, 0.2);
            color: #3b82f6;
        }

        .status-processing {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .chat-area {
            flex: 1;
            padding: 1rem 2rem;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.1);
        }

        .message {
            margin: 1rem 0;
            padding: 1rem 1.5rem;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .user-message {
            background: #0084ff;
            color: white;
            margin-left: auto;
            text-align: right;
        }

        .bot-message {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            padding: 2rem;
            display: flex;
            justify-content: center;
            gap: 2rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .control-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .mute-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .mute-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
        }

        .mute-btn.muted {
            background: #ef4444;
            color: white;
        }

        .mute-btn.listening {
            background: #22c55e;
            color: white;
            animation: pulse 2s infinite;
        }

        .end-call-btn {
            background: #ef4444;
            color: white;
        }

        .end-call-btn:hover {
            background: #dc2626;
            transform: scale(1.05);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }

        .status-text {
            text-align: center;
            padding: 1rem;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="header">
            <h1>üéØ Google Interview</h1>
            <div id="candidateInfo" class="candidate-info">
                Loading candidate information...
            </div>
            <div id="statusIndicator" class="status-indicator status-connected">
                üî¥ Connecting...
            </div>
        </div>

        <div id="chatArea" class="chat-area">
            <!-- Messages will appear here -->
        </div>

        <div id="statusText" class="status-text">
            Waiting for HR specialist to connect...
        </div>

        <div class="controls">
            <button id="muteBtn" class="control-btn mute-btn" title="Microphone">
                üé§
            </button>
            <button id="endCallBtn" class="control-btn end-call-btn" title="End Interview">
                üìû
            </button>
        </div>
    </div>

    <script>
        class VoiceInterview {
            constructor() {
                this.ws = null;
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.isListening = false;
                this.isMuted = true;
                this.userId = this.generateUserId();
                this.candidateData = null;
                this.cvData = null;
                
                // –£–ª—É—á—à–µ–Ω–Ω—ã–µ VAD –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ñ—Ä–∞–∑
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.vadThreshold = 8;  // –°–Ω–∏–∂–∞–µ–º –ø–æ—Ä–æ–≥ –¥–ª—è –ª—É—á—à–µ–≥–æ –∑–∞—Ö–≤–∞—Ç–∞ —Ç–∏—Ö–∏—Ö –∑–≤—É–∫–æ–≤
                this.silenceTimeout = 800;  // –£–º–µ–Ω—å—à–∞–µ–º –≤—Ä–µ–º—è —Ç–∏—à–∏–Ω—ã –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ñ—Ä–∞–∑
                this.silenceTimer = null;
                this.voiceDetected = false;
                this.autoStopTimeout = null;
                this.minRecordingTime = 300;  // –ú–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –∑–∞–ø–∏—Å–∏ (–º—Å)
                this.maxRecordingTime = 8000;  // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –∑–∞–ø–∏—Å–∏ (–º—Å)
                this.recordingStartTime = null;
                
                // Audio playback
                this.audioQueue = [];
                this.isPlayingAudio = false;
                this.currentAudio = null;
                
                this.initElements();
                this.loadCandidateData();
                this.initWebSocket();
            }

            generateUserId() {
                return 'user_' + Math.random().toString(36).substr(2, 9);
            }

            initElements() {
                this.statusIndicatorEl = document.getElementById('statusIndicator');
                this.chatAreaEl = document.getElementById('chatArea');
                this.statusTextEl = document.getElementById('statusText');
                this.muteBtnEl = document.getElementById('muteBtn');
                this.endCallBtnEl = document.getElementById('endCallBtn');
                this.candidateInfoEl = document.getElementById('candidateInfo');

                this.muteBtnEl.addEventListener('click', () => this.toggleMute());
                this.endCallBtnEl.addEventListener('click', () => this.endCall());
            }

            loadCandidateData() {
                try {
                    this.candidateData = JSON.parse(localStorage.getItem('candidateData'));
                    this.sessionId = localStorage.getItem('sessionId');
                    
                    if (this.candidateData) {
                        this.candidateInfoEl.textContent = 
                            `${this.candidateData.firstName} ${this.candidateData.lastName} | ${this.candidateData.email}`;
                    }
                    
                    if (!this.candidateData || !this.sessionId) {
                        this.candidateInfoEl.textContent = 'Error: Missing candidate data';
                        this.statusTextEl.textContent = 'Please go back and complete the setup form';
                        return false;
                    }
                    
                    return true;
                } catch (error) {
                    this.candidateInfoEl.textContent = 'Error loading candidate data';
                    this.statusTextEl.textContent = 'Please go back and complete the setup form';
                    return false;
                }
            }

            async initWebSocket() {
                if (!this.loadCandidateData()) return;

                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws/${this.userId}?session_id=${this.sessionId}`;
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.updateStatus('connected', 'üü¢ Connected');
                        this.updateStatusText('CV already uploaded. Starting interview...');
                    };

                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleMessage(data);
                    };

                    this.ws.onclose = () => {
                        this.updateStatus('disconnected', 'üî¥ Disconnected');
                        this.updateStatusText('Connection lost. Please refresh the page');
                    };

                    this.ws.onerror = () => {
                        this.updateStatus('error', '‚ùå Error');
                        this.updateStatusText('Connection error');
                    };

                } catch (error) {
                    this.updateStatus('error', '‚ùå Error');
                    this.updateStatusText('Failed to connect to server');
                }
            }



            updateStatus(type, text) {
                const classes = {
                    'connected': 'status-connected',
                    'listening': 'status-listening', 
                    'processing': 'status-processing',
                    'disconnected': 'status-connected',
                    'error': 'status-connected'
                };
                
                this.statusIndicatorEl.className = `status-indicator ${classes[type] || 'status-connected'}`;
                this.statusIndicatorEl.textContent = text;
            }

            updateStatusText(text) {
                this.statusTextEl.textContent = text;
            }

            addMessage(text, isUser = false) {
                const messageEl = document.createElement('div');
                messageEl.className = `message ${isUser ? 'user-message' : 'bot-message'}`;
                messageEl.textContent = text;
                
                this.chatAreaEl.appendChild(messageEl);
                this.chatAreaEl.scrollTop = this.chatAreaEl.scrollHeight;
            }

            async toggleMute() {
                if (this.isMuted) {
                    await this.startListening();
                } else {
                    this.stopListening();
                }
            }

            async startListening() {
                if (!this.ws || this.ws.readyState !== WebSocket.OPEN) return;

                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Ä–µ–≥—É–ª–∏—Ä–æ–≤–∫–∞ —É—Å–∏–ª–µ–Ω–∏—è
                            googEchoCancellation: true,
                            googAutoGainControl: true,
                            googNoiseSuppression: true,
                            googHighpassFilter: true,
                            googTypingNoiseDetection: true,
                            googAudioMirroring: false
                        }
                    });

                    this.isListening = true;
                    this.isMuted = false;
                    
                    this.muteBtnEl.classList.add('listening');
                    this.muteBtnEl.classList.remove('muted');
                    this.updateStatus('listening', 'üéß Listening');
                    this.updateStatusText('Speak! I\'m listening');

                    // Web Audio API for VAD
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    
                    this.analyser.fftSize = 512;
                    this.analyser.smoothingTimeConstant = 0.3;
                    this.microphone.connect(this.analyser);

                    // MediaRecorder —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏ –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ñ—Ä–∞–∑
                    const mimeTypes = [
                        'audio/webm;codecs=opus',
                        'audio/ogg;codecs=opus',
                        'audio/mp4;codecs=mp4a.40.2',
                        'audio/webm'
                    ];
                    
                    let selectedMimeType = 'audio/webm';
                    for (const mimeType of mimeTypes) {
                        if (MediaRecorder.isTypeSupported(mimeType)) {
                            selectedMimeType = mimeType;
                            break;
                        }
                    }
                    
                    console.log(`üéôÔ∏è Using MIME type: ${selectedMimeType}`);
                    
                    this.mediaRecorder = new MediaRecorder(stream, {
                        mimeType: selectedMimeType,
                        audioBitsPerSecond: 64000  // –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –±–∏—Ç—Ä–µ–π—Ç –¥–ª—è —Ä–µ—á–∏
                    });

                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        if (this.audioChunks.length > 0) {
                            this.processRecording();
                        }
                    };

                    this.startVoiceDetection();

                } catch (error) {
                    this.updateStatusText('Microphone access error. Please allow access and try again');
                }
            }

            stopListening() {
                this.isListening = false;
                this.isMuted = true;
                
                if (this.isRecording) {
                    this.stopRecording();
                }
                
                if (this.mediaRecorder && this.mediaRecorder.stream) {
                    this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
                }

                if (this.audioContext) {
                    this.audioContext.close();
                }

                this.muteBtnEl.classList.remove('listening');
                this.muteBtnEl.classList.add('muted');
                this.muteBtnEl.textContent = 'üîá';
                this.updateStatus('connected', 'üî¥ Microphone off');
                this.updateStatusText('Microphone off. Click to enable');
            }

            startVoiceDetection() {
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                let consecutiveDetections = 0;
                let consecutiveSilence = 0;
                const requiredDetections = 1;  // –£–º–µ–Ω—å—à–∞–µ–º –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Ä–µ–∞–≥–∏—Ä–æ–≤–∞–Ω–∏—è
                const requiredSilence = 15;    // –£–º–µ–Ω—å—à–∞–µ–º –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö –ø–∞—É–∑
                
                // –£–ª—É—á—à–µ–Ω–Ω–∞—è –¥–µ—Ç–µ–∫—Ü–∏—è –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ñ—Ä–∞–∑
                let energyHistory = [];
                const historySize = 10;
                let backgroundNoise = 0;
                let noiseCalibrated = false;

                const detectSound = () => {
                    if (!this.isListening) return;

                    this.analyser.getByteFrequencyData(dataArray);
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ –º–µ—Ç—Ä–∏–∫–∏ –∑–≤—É–∫–∞
                    let sum = 0;
                    let rms = 0;
                    let peak = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const value = dataArray[i];
                        sum += value;
                        rms += value * value;
                        peak = Math.max(peak, value);
                    }
                    
                    const average = sum / bufferLength;
                    const rmsValue = Math.sqrt(rms / bufferLength);
                    
                    // –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–µ—Ç—Ä–∏–∫–∞ –¥–ª—è –ª—É—á—à–µ–≥–æ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è
                    const energy = (average * 0.3) + (rmsValue * 0.5) + (peak * 0.2);
                    
                    // –ö–∞–ª–∏–±—Ä–æ–≤–∫–∞ —Ñ–æ–Ω–æ–≤–æ–≥–æ —à—É–º–∞
                    if (!noiseCalibrated) {
                        energyHistory.push(energy);
                        if (energyHistory.length >= historySize) {
                            backgroundNoise = energyHistory.reduce((a, b) => a + b) / historySize;
                            noiseCalibrated = true;
                            console.log(`üéß Background noise calibrated: ${backgroundNoise.toFixed(2)}`);
                        }
                        requestAnimationFrame(detectSound);
                        return;
                    }
                    
                    // –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –ø–æ—Ä–æ–≥ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–æ–Ω–æ–≤–æ–≥–æ —à—É–º–∞
                    const adaptiveThreshold = Math.max(this.vadThreshold, backgroundNoise * 1.5);
                    const isVoiceDetected = energy > adaptiveThreshold;

                    if (isVoiceDetected) {
                        consecutiveDetections++;
                        consecutiveSilence = 0;
                        
                        if (consecutiveDetections >= requiredDetections && !this.voiceDetected) {
                            this.onVoiceStart();
                        }
                        
                        if (this.silenceTimer) {
                            clearTimeout(this.silenceTimer);
                            this.silenceTimer = null;
                        }
                    } else {
                        consecutiveDetections = 0;
                        consecutiveSilence++;
                        
                        if (this.voiceDetected && consecutiveSilence >= requiredSilence && !this.silenceTimer) {
                            this.silenceTimer = setTimeout(() => {
                                this.onVoiceEnd();
                            }, this.silenceTimeout);
                        }
                    }
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –∏—Å—Ç–æ—Ä–∏—é —ç–Ω–µ—Ä–≥–∏–∏ –¥–ª—è –∞–¥–∞–ø—Ç–∞—Ü–∏–∏ –∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º
                    if (energyHistory.length >= historySize) {
                        energyHistory.shift();
                    }
                    energyHistory.push(energy);

                    requestAnimationFrame(detectSound);
                };

                detectSound();
            }

            onVoiceStart() {
                if (this.isRecording) return;

                this.isRecording = true;
                this.voiceDetected = true;
                this.audioChunks = [];
                this.recordingStartTime = Date.now();
                
                console.log('üé§ Voice detection started');
                this.updateStatusText('üé§ Recording...');
                
                // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –Ω–∞—á–∞–ª–µ –∑–∞–ø–∏—Å–∏ –≥–æ–ª–æ—Å–∞ –¥–ª—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ç–∞–π–º–µ—Ä–∞ —Ç–∞–π–º–∞—É—Ç–∞
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'voice_start'
                    }));
                    console.log('üì§ Sent voice_start message to stop timeout timer');
                }
                
                this.mediaRecorder.start();
                
                // –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π —Ç–∞–π–º–∞—É—Ç –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ñ—Ä–∞–∑
                this.autoStopTimeout = setTimeout(() => {
                    if (this.isRecording) {
                        console.log('‚è∞ Auto-stopping recording due to timeout');
                        this.onVoiceEnd();
                    }
                }, this.maxRecordingTime);
            }

            onVoiceEnd() {
                if (!this.isRecording) return;

                const recordingDuration = Date.now() - this.recordingStartTime;
                console.log(`üé§ Voice detection ended after ${recordingDuration}ms`);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–∞–ø–∏—Å–∏
                if (recordingDuration < this.minRecordingTime) {
                    console.log(`‚ö†Ô∏è Recording too short (${recordingDuration}ms), ignoring`);
                    this.isRecording = false;
                    this.voiceDetected = false;
                    this.audioChunks = [];
                    
                    if (this.autoStopTimeout) {
                        clearTimeout(this.autoStopTimeout);
                        this.autoStopTimeout = null;
                    }
                    
                    this.updateStatusText('üéß Listening...');
                    return;
                }

                this.voiceDetected = false;
                this.silenceTimer = null;
                
                if (this.autoStopTimeout) {
                    clearTimeout(this.autoStopTimeout);
                    this.autoStopTimeout = null;
                }
                
                this.stopRecording();
            }

            stopRecording() {
                if (!this.isRecording) return;

                this.isRecording = false;
                this.mediaRecorder.stop();
                this.updateStatusText('üì§ Processing...');
            }

            async processRecording() {
                if (this.audioChunks.length === 0) {
                    console.log('‚ö†Ô∏è No audio chunks to process');
                    return;
                }

                try {
                    const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
                    console.log(`üì§ Processing audio blob: ${audioBlob.size} bytes`);
                    
                    // –°–Ω–∏–∂–∞–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è –∫–æ—Ä–æ—Ç–∫–∏—Ö —Ñ—Ä–∞–∑
                    if (audioBlob.size < 50) {
                        console.log('‚ö†Ô∏è Audio blob too small, skipping');
                        return;
                    }
                    
                    const arrayBuffer = await audioBlob.arrayBuffer();
                    const audioData = new Uint8Array(arrayBuffer);
                    const base64Audio = btoa(String.fromCharCode.apply(null, audioData));
                    
                    console.log(`üì§ Sending audio data: ${base64Audio.length} chars`);
                    
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify({
                            type: 'audio',
                            audio: base64Audio,
                            metadata: {
                                size: audioBlob.size,
                                duration: this.recordingStartTime ? Date.now() - this.recordingStartTime : 0,
                                chunks: this.audioChunks.length
                            }
                        }));
                    } else {
                        console.log('‚ö†Ô∏è WebSocket not ready, cannot send audio');
                    }

                } catch (error) {
                    console.error('‚ùå Recording processing error:', error);
                    this.updateStatusText('‚ùå Recording processing error');
                }
            }

            handleMessage(data) {
                switch (data.type) {
                    case 'connected':
                        this.updateStatusText(data.message);
                        break;



                    case 'status':
                        this.updateStatus('processing', 'ü§î Thinking');
                        this.updateStatusText(data.message);
                        break;

                    case 'user_text':
                        this.addMessage(data.text, true);
                        break;

                    case 'bot_text':
                        this.addMessage(data.text, false);
                        this.updateStatus('processing', 'üîä Speaking');
                        this.updateStatusText('Playing response...');
                        break;

                    case 'audio_chunk':
                        this.queueAudioChunk(data.audio, data.chunk_index, data.total_chunks);
                        break;

                    case 'completed':
                        // Auto-enable microphone after HR response
                        if (this.isMuted) {
                            this.startListening();
                        } else {
                            this.updateStatus('listening', 'üéß Listening');
                            this.updateStatusText('Ready for your response');
                        }
                        break;

                    case 'error':
                        this.updateStatusText('‚ùå ' + data.message);
                        break;
                }
            }

            queueAudioChunk(base64Audio, chunkIndex, totalChunks) {
                this.audioQueue.push({
                    audio: base64Audio,
                    index: chunkIndex,
                    total: totalChunks
                });

                if (!this.isPlayingAudio) {
                    this.playNextChunk();
                }
            }

            async playNextChunk() {
                if (this.audioQueue.length === 0) {
                    this.isPlayingAudio = false;
                    return;
                }

                this.isPlayingAudio = true;
                const chunk = this.audioQueue.shift();

                try {
                    const audioUrl = await this.createAudioUrl(chunk.audio);
                    const audio = new Audio(audioUrl);
                    this.currentAudio = audio;

                    this.updateStatusText(`üîä Playing chunk ${chunk.index + 1}/${chunk.total}`);

                    audio.addEventListener('ended', () => {
                        URL.revokeObjectURL(audioUrl);
                        this.currentAudio = null;
                        
                        // Check if this was the last chunk
                        if (chunk.index === chunk.total - 1) {
                            // All audio chunks have finished playing
                            this.onAudioPlaybackComplete();
                        }
                        
                        this.playNextChunk();
                    });

                    audio.addEventListener('error', () => {
                        URL.revokeObjectURL(audioUrl);
                        this.currentAudio = null;
                        this.playNextChunk();
                    });

                    await audio.play();

                } catch (error) {
                    this.playNextChunk();
                }
            }

            async createAudioUrl(base64Audio) {
                return new Promise((resolve, reject) => {
                    try {
                        const binaryString = atob(base64Audio);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }

                        const audioBlob = new Blob([bytes], { type: 'audio/mpeg' });
                        const audioUrl = URL.createObjectURL(audioBlob);
                        resolve(audioUrl);
                    } catch (error) {
                        reject(error);
                    }
                });
            }

            onAudioPlaybackComplete() {
                // Notify server that audio playback is complete
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'audio_playback_complete'
                    }));
                }
                
                console.log('üîä Audio playback completed, notifying server');
            }

            endCall() {
                if (this.isListening) {
                    this.stopListening();
                }
                
                this.stopAudioPlayback();
                
                if (this.ws) {
                    this.ws.close();
                }
                
                this.updateStatus('disconnected', 'üìû Interview ended');
                this.updateStatusText('Interview completed. Thank you!');
                
                this.muteBtnEl.disabled = true;
                this.endCallBtnEl.disabled = true;
                
                // Clear localStorage
                localStorage.removeItem('candidateData');
                localStorage.removeItem('sessionId');
                
                // Redirect back to setup after 3 seconds
                setTimeout(() => {
                    window.location.href = '/';
                }, 3000);
            }

            stopAudioPlayback() {
                this.audioQueue = [];
                this.isPlayingAudio = false;
                
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio = null;
                }
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new VoiceInterview();
        });
    </script>
</body>
</html> 